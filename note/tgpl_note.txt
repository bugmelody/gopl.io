================================================================================================================================
Go does not require semicolons at the ends of statements or declarations, except where two or
more appear on the same line. In effect, newlines following certain tokens are converted into
semicolons, so where newlines are placed matters to proper parsing of Go code. For instance,
the opening brace { of the function must be on the same line as the end of the func declaration,
not on a line by itself, and in the expression x + y, a newline is permitted after but not
before the + operator.
================================================================================================================================
goimports, additionally manages the insertion and removal of import declarations as needed.
It is not part of the standard distribution but you can obtain it with this command:
$ go get golang.org/x/tools/cmd/goimports
================================================================================================================================
The increment statement i++ adds 1 to i; it’s equivalent to i += 1 which is in turn equivalent
to i = i + 1. There’s a corresponding decrement statement i-- that subtracts 1. These are
statements, not expressions as they are in most languages in the C family, so j = i++ is illegal,
and they are postfix only, so --i is not legal either.
================================================================================================================================
func main() {
	s, sep := "", ""
	for _, arg := range os.Args[1:] {
		s += sep + arg
		sep = " "
	}
	fmt.Println(s)
}

each time around the loop, the string s gets completely new contents. The +=
statement makes a new string by concatenating the old string, a space character, and the next
argument, then assigns the new string to s. The old contents of s are no longer in use, so they
will be garbage-collected in due course.
in due course: 在适当的时候；及时地；顺次

If the amount of data involved is large, this could be costly.
================================================================================================================================
godoc -analysis=type -http=:6060生成带继承关系的Go doc，并且它还可以将你本地下载的库中的继承关系也显示出来
================================================================================================================================
The example below shows an application of a buffered channel. It makes parallel requests to
three mirrors, that is, equivalent but geographically distributed servers. It sends their
responses over a buffered channel, then receives and returns only the first response, which is
the quickest one to arrive. Thus mirroredQuery returns a result even before the two slower
servers have responded. (Incidentally, it's quite normal for several goroutines to send values to
the same channel concurrently, as in this example, or to receive from the same channel.)
incidentally [ɪnsɪ'dent(ə)lɪ] adv. 顺便；偶然地；附带地

func mirroredQuery() string {
  responses := make(chan string, 3) // 缓冲长度为 3 的 channel
  go func() { responses <- request("asia.gopl.io") }()
  go func() { responses <- request("europe.gopl.io") }()
  go func() { responses <- request("americas.gopl.io") }()
  return <-responses // return the quickest response
}

func request(hostname string) (response string) { /* ... */ }

Had we used an unbuffered channel, the two slower goroutines would have gotten stuck trying
to send their responses on a channel from which no goroutine will ever receive.
也就是,慢的两个goroutines由于没有对应的接收操作,因此这两个goroutines的send操作会永远阻塞,导致这两个goroutines永远不会结束.

This situation, called a goroutine leak, would be a bug. Unlike garbage variables, leaked goroutines are not
automatically collected, so it is important to make sure that goroutines terminate themselves when no longer needed.
当goroutines由于不小心的操作导致无法退出,goroutines会永久存在,不会被垃圾收集.因此,将不再需要的goroutines结束是非常重要的.
================================================================================================================================
Sometimes we want to try to send or receive on a channel but avoid blocking if the channel is
not ready—a non-blocking communication. A select statement can do that too. A select
may have a default, which specifies what to do when none of the other communications can
proceed immediately.

The select statement below receives a value from the abort channel if there is one to receive;
other wise it does nothing. This is a non-blocking receive operation; doing it repeatedly is
called polling a channel.
poll [pəʊl]
n. 投票；民意测验；投票数；投票所
vt. 投票；剪短；对…进行民意测验；获得选票
vi. 投票
adj. 无角的；剪过毛的；修过枝的
vt. 顺序询问，轮询；探询

select {
case <-abort:
  fmt.Printf("Launch aborted!\n")
  return
default:
  // do nothing
}

The zero value for a channel is nil. Perhaps surprisingly, nil channels are sometimes useful.
Because send and receive operations on a nil channel block forever, a case in a select statement
whose channel is nil is never selected. This lets us use nil to enable or disable cases that correspond
to features like handling timeouts or cancellation, responding to other input events, or emitting output.
================================================================================================================================
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		/**
		Each time reads a line of input, the line is used as a key into the map and the corresponding
		value is incremented. The statement counts[input.Text()]++ is equivalent to
		these two statements:
		
		line := input.Text()
		counts[line] = counts[line] + 1
		
		It's not a problem if the map doesn't yet contain that key. The first time a new line is seen, the
		expression counts[line] on the right-hand side evaluates to the zero value for its type, which is 0 for int.
		*/
		counts[input.Text()]++
	}

	if err := input.Err(); err != nil {
		fmt.Println("err")
		return
	}

	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
================================================================================================================================
const declarations may appear at package level (so the names are visible throughout the package) or
within a function (so the names are visible only within that function). 
================================================================================================================================
The zero value for a pointer of any type is nil. The test p != nil is true if p points to a variable.
Pointers are comparable; two pointers are equal if and only if they point to the same variable or both are nil.
================================================================================================================================
It is perfectly safe for a function to return the address of a local variable. For instance, in the
code below, the local variable v created by this particular call to f will remain in existence even
after the call has returned, and the pointer p will still refer to it:

var p = f()
func f() *int {
  v := 1
  return &v
}

Each call of f returns a distinct value:

fmt.Println(f() == f()) // "false"
================================================================================================================================
p40:
Comparison operators like == and < can also be used to compare a value of a named type to
another of the same type, or to a value of the underlying type. But two values of different
named types cannot be compared directly :

type Celsius float64
type Fahrenheit float64
const (
  AbsoluteZeroC Celsius = -273.15
  FreezingC Celsius = 0
  BoilingC Celsius = 100
)
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }


var c Celsius
var f Fahrenheit
fmt.Println(c == 0) // "true"
fmt.Println(f >= 0) // "true"
fmt.Println(c == f) // compile error: type mismatch
fmt.Println(c == Celsius(f)) // "true"!

Note the last case carefully. In spite of its name, the type conversion Celsius(f) does not
change the value of its argument, just its type. The test is true because c and f are both zero.
Celsius(f) 虽然叫做类型转换,但并不会修改参数f的值,仅仅是修改了f的类型.
================================================================================================================================
p47:
The code in the following if-else chain shows the scope of x and y:

if x := f(); x == 0 {
  fmt.Println(x)
} else if y := g(x); x == y {
  fmt.Println(x, y)
} else {
  fmt.Println(x, y)
}
fmt.Println(x, y) // compile error: x and y are not visible here

The second if statement is nested within the first, so variables declared within the first statement's initializer
are visible within the second. Similar rules apply to each case of a switch
statement: there is a block for the condition and a block for each case body.
================================================================================================================================
The behavior of % for negative numbers varies across programming languages. In Go, the sign of the remainder is
always the same as the sign of the dividend, so -5%3 and -5%-3 are both -2. The behavior of /
depends on whether its operands are integers, so 5.0/4.0 is 1.25, but 5/4 is 1 because integer
division truncates the result toward zero.
dividend ['dɪvɪdend] n. 红利；股息；[数] 被除数；奖金
================================================================================================================================
p53
If the result of an arithmetic operation, whether signed or unsigned, has more bits than can be
represented in the result type, it is said to overflow. The high-order bits that do not fit are
silently discarded. If the original number is a signed type, the result could be negative if the
leftmost bit is a 1, as in the int8 example here:

var u uint8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"
var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 -128 1"
================================================================================================================================
p53:
Go also provides the following bitwise binary operators, the first four of which treat their operands as
bit patterns with no concept of arithmetic carry(进位) or sign:
&     bitwise AND
|     bitwise OR
^     bitwise XOR(相同为0,相异为1)
&^    bit clear (AND NOT) (右操作数为1的位,在结果中对应为0)
<<    left shift
>>    right shift

The operator ^ is bitwise exclusive OR (XOR) when used as a binary operator, but when used
as a unary prefix operator it is bitwise negation or complement; that is, it returns a value with
each bit in its operand inverted. The &^ operator is bit clear (AND NOT): in the expression
z = x &^ y, each bit of z is 0 if the corresponding bit of y is 1; otherwise it equals the corresponding bit of x.

package main

import (
	"fmt"
)

func main() {
	var x uint8 = 1<<1 | 1<<5 // "00100010"
	var y uint8 = 1<<1 | 1<<2 // "00000110"
	fmt.Printf("%08b\n", x)   // "00100010", the set {1, 5}
	fmt.Printf("%08b\n", y)   // "00000110", the set {1, 2}
	fmt.Printf("%08b\n", x&y) // "00000010", the intersection {1}
	fmt.Printf("%08b\n", x|y) // "00100110",	the	union {1, 2, 5}
	fmt.Printf("%08b\n", x^y) // "00100100", the symmetric difference {2, 5}, 异或, 相同为0,相异为1

	/**
	The &^ operator is bit clear (AND NOT): in the expression
	z = x &^ y, each bit of z is 0 if the corresponding bit of y is 1; otherwise it equals the corresponding bit of x
	*/
	fmt.Printf("%08b\n", x&^y) // "00100000", the difference {5}, [[bit clear (AND NOT)]]

	for i := uint(0); i < 8; i++ {
		if x&(1<<i) != 0 { // membership test, 测试 x 中哪些位是1
			fmt.Println(i) // "1", "5"
		}
	}
	fmt.Printf("%08b\n", x<<1) // "01000100", the set {2, 6}
	fmt.Printf("%08b\n", x>>1) // "00010001", the set {0, 4}

}
================================================================================================================================
p54
Arithmetically, a left shift x<<n is equivalent to multiplication by 2的n次方 and a right shift x>>n is equivalent to the floor
of division by 2的n次方.
================================================================================================================================
p54
Left shifts fill the vacated bits with zeros, as do right shifts of unsigned numbers, but right
shifts of signed numbers fill the vacated bits with copies of the sign bit. For this reason, it is
important to use unsigned arithmetic when you're treating an integer as a bit pattern.

vacate [veɪ'keɪt; və'keɪt]
vi. 空出，腾出；辞职；休假
vt. 空出，搬出；取消；使撤退
================================================================================================================================
到此
p54
Although Go provides unsigned numbers and arithmetic, we tend to use the signed int form
even for quantities that can't be negative, such as the length of an array, though uint might
seem a more obvious choice. Indeed, the built-in len function returns a signed int, as in this
loop which announces prize medals in reverse order:

medals := []string{"gold", "silver", "bronze"}
for i := len(medals) - 1; i >= 0; i-- {
  fmt.Println(medals[i]) // "bronze", "silver", "gold"
}

The alternative would be calamitous. If len returned an unsigned number, then i too would
be a uint, and the condition i >= 0 would always be true by definition. After the third itera-
tion, in which i == 0, the i-- statement would cause i to become not −1, but the maximum
uint value (for example, 264−1), and the evaluation of medals[i] would fail at run time, or
panic (§5.9), by attempting to access an element outside the bounds of the slice.
================================================================================================================================
p55
Many integer-to-integer conversions do not entail any change in value; they just tell the compiler how
to interpret a value. But a conversion that narrows a big integer into a smaller one, or a conversion
from integer to floating-point or vice versa, may change the value or lose precision:

f := 3.141 // a float64
i := int(f)
fmt.Println(f, i) // "3.141 3"
f = 1.99
fmt.Println(int(f)) // "1"

Float to integer conversion discards any fractional part, truncating toward zero. You should
avoid conversions in which the operand is out of range for the target type, because the behavior
depends on the implementation:

f := 1e100 // a float64
i := int(f) // result is implementation-dependent
================================================================================================================================
p55,p56
When printing numbers using the fmt package, we can control the radix and format with the
%d, %o, and %x verbs, as shown in this example:

o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF

Note the use of two fmt tricks. Usually a Printf format string containing multiple % verbs
would require the same number of extra operands, but the [1] "adverbs" after % tell Printf to
use the first operand over and over again. Second, the # adverb for %o or %x or %X tells Printf
to emit a 0 or 0x or 0X prefix respectively.

Rune literals are written as a character within single quotes. The simplest example is an ASCII
character like 'a', but it's possible to write any Unicode code point either directly or with
numeric escapes, as we will see shortly.

Runes are printed with %c, or with %q if quoting is desired:

ascii := 'a'
unicode := '国'
newline := '\n' // 注意,单引号是 rune, 而 rune 是接受 \n 这样的转义形式的
fmt.Printf("%d %[1]c %[1]q\n", ascii) // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline) // "10 '\n'"
================================================================================================================================
p56
A float32 provides approximately six decimal digits of precision, whereas a float64
provides about 15 digits; float64 should be preferred for most purposes because float32
computations accumulate error rapidly unless one is quite careful, and the smallest positive
integer that cannot be exactly represented as a float32 is not large:

var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1) // "true"!
================================================================================================================================
Floating-point values are conveniently printed with Printf's %g verb, which chooses the most
compact representation that has adequate precision, but for tables of data, the %e (exponent)
or %f (no exponent) forms may be more appropriate. All three verbs allow field width and
numeric precision to be controlled.

for x := 0; x < 8; x++ {
  fmt.Printf("x = %d e x = %8.3f\n", x, math.Exp(float64(x)))
}


###打印为如下结果
x = 0 e x =    1.000
x = 1 e x =    2.718
x = 2 e x =    7.389
x = 3 e x =   20.086
x = 4 e x =   54.598
x = 5 e x =  148.413
x = 6 e x =  403.429
x = 7 e x = 1096.633
###

The code above prints the powers of e with three decimal digits of precision, aligned in an eight-character field
================================================================================================================================
The function math.IsNaN tests whether its argument is a not-a-number value, and math.NaN
returns such a value. It's tempting to use NaN as a sentinel value in a numeric computation,
but testing whether a specific computational result is equal to NaN is fraught with peril
because any comparison with NaN always yields false:
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
================================================================================================================================
If a function that returns a floating-point result might fail, it's better to report the failure separately, like this:

func compute() (value float64, ok bool) {
  // ...
  if failed {
    return 0, false
  }
  return result, true
}


??????????????????????????????????????????????????????????????????????????
================================================================================================================================
Since && has higher precedence than || (mnemonic: && is boolean multiplication, || is
boolean addition), no parentheses are required for conditions of this form:

if 'a' <= c && c <= 'z' ||
  'A' <= c && c <= 'Z' ||
  '0' <= c && c <= '9' {
  // ...ASCII letter or digit...
}

================================================================================================================================
The built-in len function returns the number of bytes (not runes) in a string, and the index
operation s[i] retrieves the i-th byte of string s, where 0 ≤ i < len(s).

s := "hello, world"
fmt.Println(len(s)) // "12"
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')

The i-th byte of a string is not necessarily the i-th character of a string, because the UTF-8
encoding of a non-ASCII code point requires two or more bytes.

The + operator makes a new string by concatenating two strings:
fmt.Println("goodbye" + s[5:]) // "goodbye, world"

Strings may be compared with comparison operators like == and <; the comparison is done
byte by byte, so the result is the natural lexicographic ordering.

String values are immutable: the byte sequence contained in a string value can never be
changed, though of course we can assign a new value to a string variable. To append one
string to another, for instance, we can write

s := "left foot"
t := s
s += ", right foot"

This does not modify the string that s originally held but causes s to hold the new string
formed by the += statement; meanwhile, t still contains the old string.

fmt.Println(s) // "left foot, right foot"
fmt.Println(t) // "left foot"

Since strings are immutable, constructions that try to modify a string's data in place are not allowed:

s[0] = 'L' // compile error: cannot assign to s[0]

Immutability means that it is safe for two copies of a string to share the same underlying
memory, making it cheap to copy strings of any length. Similarly, a string s and a substring
like s[7:] may safely share the same data, so the substring operation is also cheap. No new
memory is allocated in either case. Figure 3.4 illustrates the arrangement of a string and two
of its substrings sharing the same underlying byte array.

A raw string literal is written `...`, using backquotes instead of double quotes. Within a raw
string literal, no escape sequences are processed; the contents are taken literally, including
backslashes and newlines, so a raw string literal may spread over several lines in the program
source. The only processing is that carriage returns are deleted so that the value of the string
is the same on all platforms, including those that conventionally put carriage returns in text
files.
================================================================================================================================
p68
Thanks to the nice properties of UTF-8, many string operations don't require decoding. We
can test whether one string contains another as a prefix:

func HasPrefix(s, prefix string) bool {
  return len(s) >= len(prefix) && s[:len(prefix)] == prefix
}

or as a suffix:

func HasSuffix(s, suffix string) bool {
  return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}
or as a substring:

func Contains(s, substr string) bool {
  for i := 0; i < len(s); i++ {
    if HasPrefix(s[i:], substr) {
      return true
    }
  }
  return false
}

using the same logic for UTF-8-encoded text as for raw bytes. This is not true for other
encodings. (The functions above are drawn from the strings package, though its implementation
of Contains uses a hashing technique to search more efficiently.)
================================================================================================================================

package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	s := "Hello, 世界"
	fmt.Println(len(s))                    // "13"
	fmt.Println(utf8.RuneCountInString(s)) // "9"

	for i := 0; i < len(s); {
		r, size := utf8.DecodeRuneInString(s[i:])
		fmt.Printf("%d\t%c\n", i, r)
		i += size
	}

	/**	Each call to DecodeRuneInString returns r, the rune itself, and size, the number of bytes
	occupied by the UTF-8 encoding of r. The size is used to update the byte index i of the next
	rune in the string. But this is clumsy, and we need loops of this kind all the time. Fortunately,
	Go's range loop, when applied to a string, performs UTF-8 decoding implicitly. The output of
	the loop below is also shown in Figure 3.5; notice how the index jumps by more than 1 for
	each non-ASCII rune.	*/

	for i1, r1 := range s {
		fmt.Printf("%d\t%q\t%d\n", i1, r1, r1)
	}

	// We could use a simple range loop to count the number of runes in a string, like this:
	n := 0
	for range s {
		n++
	}
	fmt.Println("n: ", n)


	/** A []rune conversion applied to a UTF-8-encoded string returns the sequence of Unicode code points that the string encodes:
  (The verb % x in the first Printf inserts a space between each pair of hex digits.)
	*/
	s2 := "代表我们传递一"
	fmt.Printf("% x\n", s2)
	r2 := []rune(s2)
	fmt.Printf("%x\n", r2)
	// If a slice of runes is converted to a string, it produces the concatenation of the UTF-8 encodings of each rune:
	fmt.Println(string(r2))

	/////////////////////////////////////

	/**Converting an integer value to a string interprets the integer as a rune value, and yields the
	UTF-8 representation of that rune:*/
	fmt.Println(string(65))	// "A", not "65"
	fmt.Println(string(0x4eac)) // 京
	// If the rune is invalid, the replacement character is substituted:
	fmt.Println(string(1234567)) // �

}
================================================================================================================================
Because strings are immutable, building up strings incrementally can involve a lot of allocation and copying.
In such cases, it's more efficient to use the bytes.Buffer type
================================================================================================================================
Strings can be converted to byte slices and back again:

s := "abc"
b := []byte(s)
s2 := string(b)

Conceptually, the []byte(s) conversion allocates a new byte array holding a copy of the bytes
of s, and yields a slice that references the entirety of that array. An optimizing compiler may
be able to avoid the allocation and copying in some cases, but in general copying is required to
ensure that the bytes of s remain unchanged even if those of b are subsequently modified. The
conversion from byte slice back to string with string(b) also makes a copy, to ensure
immutability of the resulting string s2.

To avoid conversions and unnecessary memory allocation, many of the utility functions in the
bytes package directly parallel their counterparts in the strings package. For example, here
are half a dozen functions from strings:

func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string

and the corresponding ones from bytes:

func Contains(b, subslice []byte) bool
func Count(s, sep []byte) int
func Fields(s []byte) [][]byte
func HasPrefix(s, prefix []byte) bool
func Index(s, sep []byte) int
func Join(s [][]byte, sep []byte) []byte

The only difference is that strings have been replaced by byte slices.
================================================================================================================================
The bytes package provides the Buffer type for efficient manipulation of byte slices. A
Buffer starts out empty but grows as data of types like string, byte, and []byte are written
to it. As the example below shows, a bytes.Buffer variable requires no initialization because
its zero value is usable:

gopl.io/ch3/printints

When appending the UTF-8 encoding of an arbitrary rune to a bytes.Buffer, it's best to use
bytes.Buffer's WriteRune method, but WriteByte is fine for ASCII characters such as '['
and ']'.
================================================================================================================================
package main

import (
	"fmt"
	"strconv"
)

func main() {
	x := 123
	y := fmt.Sprintf("%d", x)
	fmt.Println(y, strconv.Itoa(x))

	fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"

	s := fmt.Sprintf("x=%b", x) // "x=1111011"
	fmt.Println(s)

	x1, _ := strconv.Atoi("123")
	fmt.Println(x1)
	
	y1, _ := strconv.ParseInt("123", 10, 64)
	fmt.Println(y1)
}
================================================================================================================================
Since constant values are known to the compiler, constant expressions may appear in types, specifically
as the length of an array type:

const IPv4Len = 4
// parseIPv4 parses an IPv4 address (d.d.d.d).
func parseIPv4(s string) IP {
  var p [IPv4Len]byte
  // ...
}
================================================================================================================================
gopl.io/ch3/netflag
================================================================================================================================
it is possible to specify a list of index and value pairs, like this:

type Currency int
const (
  USD Currency = iota
  EUR
  GBP
  RMB
)
symbol := [...]string{USD: "$", EUR: "€", GBP: "X", RMB: "￥"}
fmt.Println(RMB, symbol[RMB]) // "3 ￥"

In this form, indices can appear in any order and some may be omitted; as before, unspecified
values take on the zero value for the element type. For instance,

r := [...]int{99: -1}
defines an array r with 100 elements, all zero except for the last, which has value −1.
================================================================================================================================
If an array's element type is comparable then the array type is comparable too, so we may
directly compare two arrays of that type using the == operator, which reports whether all corresponding
elements are equal. The != operator is its negation.
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
================================================================================================================================
gopl.io/ch4/sha256 注意 fmt.Printf("%x\n%x\n%t\n%T\n", c1, c2, c1 == c2, c1) 的用法
================================================================================================================================
https://docs.ruanjiadeng.com/gopl-zh/ch4/ch4-02.html 翻译

Unlike arrays, slices are not comparable, so we cannot use == to test whether two slices contain the same
elements. The standard library provides the highly optimized bytes.Equal function for comparing two slices
of bytes ([]byte), but for other types of slice, we must do the comparison ourselves:

func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}

Given how natural this "deep" equality test is, and that it is no more costly at run time than the == operator
for arrays of strings, it may be puzzling that slice comparisons do not also work this way. There are two reasons
why deep equivalence is problematic. First, unlike array elements, the elements of a slice are indirect, making
it possible for a slice to contain itself. Although there are ways to deal with such cases, none is simple, efficient, and
most importantly, obvious.

Second, because slice elements are indirect, a fixed slice value may contain different elements at different times
as the contents of the underlying array are modified. Because a hash table such as Go's map type makes only shallow
copies of its keys, it requires that equality for each key remain the same throughout the lifetime of the hash
table. Deep equivalence would thus make slices unsuitable for use as map keys. For reference types like pointers
and channels, the == operator tests reference identity, that is, whether the two entities refer to the same thing. An
analogous "shallow" equality test for slices could be useful, and it would solve the problem with maps, but the
inconsistent treatment of slices and arrays by the == operator would be confusing. The safest choice is to disallow
slice comparisons altogether.

The only legal slice comparison is against nil, as in

if summer == nil { /* ... */ }

The zero value of a slice type is nil. A nil slice has no underlying array. The nil slice has length and capacity
zero, but there are also non-nil slices of length and capacity zero, such as []int{} or make([]int, 3)[3:]. As with
any type that can have nil values, the nil value of a particular slice type can be written using a conversion expression
such as []int(nil).

var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil

So, if you need to test whether a slice is empty, use len(s) == 0, not s == nil. Other than comparing equal
to nil, a nil slice behaves like any other zero-length slice; reverse(nil) is perfectly safe, for example. Unless
clearly documented to the contrary, Go functions should treat all zero-length slices the same way, whether nil or non-nil. 
================================================================================================================================
package main

import (
	"fmt"
)

func main() {
	var runes []rune
	for _, r := range "Hello, 世界" {
		runes = append(runes, r)
	}
	fmt.Printf("%q\n", runes) // ['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']
}

The loop uses append to build the slice of nine runes encoded by the string literal, although this
specific problem is more conveniently solved by using the built-in conversion []rune("Hello, 世界"). 

为什么slice没有经过make也能使用呢???? 因为 append可以作用于 nil slice 和 非 nil slice,行为是一样的
================================================================================================================================
The built-in append function may use a more sophisticated growth strategy than appendInt's simplistic
one. Usually we don't know whether a given call to append will cause a reallocation, so we can't assume
that the original slice refers to the same array as the resulting slice, nor that it refers to a different
one. Similarly, we must not assume that assignments to elements of the old slice will (or will not) be
reflected in the new slice. Consequently, it's usual to assign the result of a call to append to the same
slice variable whose value we passed to append:

runes = append(runes, r)

Updating the slice variable is required not just when calling append, but for any function that may change
the length or capacity of a slice or make it refer to a different underlying array. To use slices
correctly, it's important to bear in mind that although the elements of the underlying array are indirect,
the slice's pointer, length, and capacity are not. To update them requires an assignment like the one above.
In this respect, slices are not "pure" reference types but resemble an aggregate type such as this struct:

type IntSlice struct {
    ptr      *int
    len, cap int
}
================================================================================================================================
A slice can be used to implement a stack. Given an initially empty slice stack, we can push a new value
onto the end of the slice with append:

stack = append(stack, v) // push v

The top of the stack is the last element:

top := stack[len(stack)-1] // top of stack

and shrinking the stack by popping that element is

stack = stack[:len(stack)-1] // pop

To remove an element from the middle of a slice, preserving the order of the remaining elements, use
copy to slide the higher-numbered elements down by one to fill the gap:

func remove(slice []int, i int) []int {
    copy(slice[i:], slice[i+1:])
    return slice[:len(slice)-1]
}

func main() {
    s := []int{5, 6, 7, 8, 9}
    fmt.Println(remove(s, 2)) // "[5 6 8 9]"
}

And if we don't need to preserve the order, we can just move the last element into the gap:

func remove(slice []int, i int) []int {
    slice[i] = slice[len(slice)-1]
    return slice[:len(slice)-1]
}

func main() {
    s := []int{5, 6, 7, 8, 9}
    fmt.Println(remove(s, 2)) // "[5 6 9 8]
}
================================================================================================================================
a map element is not a variable, and we cannot take its address:

_ = &ages["bob"] // compile error: cannot take address of map element

One reason that we can't take the address of a map element is that growing a map might cause
rehashing of existing elements into new storage locations, thus potentially invalidating the address. 
================================================================================================================================
The zero value for a map type is nil, that is, a reference to no hash table at all.

var ages map[string]int
fmt.Println(ages == nil)    // "true"
fmt.Println(len(ages) == 0) // "true"

Most operations on maps, including lookup, delete, len, and range loops, are safe to perform on a nil map
reference, since it behaves like an empty map. But storing to a nil map causes a panic:

ages["carol"] = 21 // panic: assignment to entry in nil map

You must allocate the map before you can store into it. 

qc注: 对于 slice 和 append 就不是这样, append 可以作用于 nil slice, 待验证!!!
================================================================================================================================
As with slices, maps cannot be compared to each other; the only legal comparison is with nil. To test
whether two maps contain the same keys and the same associated values, we must write a loop:

func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false
    }
    for k, xv := range x {
        if yv, ok := y[k]; !ok || yv != xv {
            return false
        }
    }
    return true
}

Observe how we use !ok to distinguish the "missing" and "present but zero" cases. Had we naïvely written xv != y[k], the
call below would incorrectly report its arguments as equal: 

equal(map[string]int{"A": 0}, map[string]int{"B": 42}) // True if equal is written incorrectly.
================================================================================================================================
gopl.io/ch4/graph

The addEdge function shows the idiomatic way to populate a map lazily, that is, to initialize
each value as its key appears for the first time. The hasEdge function shows how the zero
value of a missing map entry is often put to work: even if neither from nor to is present,
graph[from][to] will always give a meaningful result.
?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
================================================================================================================================
type Employee struct {
    ID        int
    Name      string
    Address   string
    DoB       time.Time
    Position  string
    Salary    int
    ManagerID int
}

var dilbert Employee

The individual fields of dilbert are accessed using dot notation like dilbert.Name and dilbert.DoB. Because
dilbert is a variable, its fields are variables too, so we may assign to a field:

dilbert.Salary -= 5000 // demoted, for writing too few lines of code

or take its address and access it through a pointer:

position := &dilbert.Position
*position = "Senior " + *position // promoted, for outsourcing to Elbonia

The dot notation also works with a pointer to a struct:

var employeeOfTheMonth *Employee = &dilbert
employeeOfTheMonth.Position += " (proactive team player)"

The last statement is equivalent to

(*employeeOfTheMonth).Position += " (proactive team player)"

Given an employee's unique ID, the function EmployeeByID returns a pointer to an Employee
struct. We can use the dot notation to access its fields:

func EmployeeByID(id int) *Employee { /* ... */ }
fmt.Println(EmployeeByID(dilbert.ManagerID).Position) // "Pointy-haired boss"

id := dilbert.ID
EmployeeByID(id).Salary = 0 // fired for... no real reason

The last statement updates the Employee struct that is pointed to by the result of the
call to EmployeeByID. If the result type of EmployeeByID were changed to Employee instead
of *Employee, the assignment statement would not compile since its left-hand side would not
identify a variable. 
================================================================================================================================
Fields are usually written one per line, with the field's name preceding its type, but consecutive
fields of the same type may be combined, as with Name and Address here:

type Employee struct {
    ID            int
    Name, Address string
    DoB           time.Time
    Position      string
    Salary        int
    ManagerID     int
}

Field order is significant to type identity. Had we also combined the declaration of the Position
field (also a string), or interchanged Name and Address, we would be defining a different struct
type. Typically we only combine the declarations of related fields. 
================================================================================================================================
Struct types tend to be verbose because they often involve a line for each field. Although we could write out
the whole type each time it is needed, the repetition would get tiresome. Instead, struct types usually appear
within the declaration of a named type like Employee.
(这就是通常使用 type Employee struct {...} 的原因)

A named struct type S can't declare a field of the same type S: an aggregate value cannot contain itself. (An
analogous restriction applies to arrays.) But S may declare a field of the pointer type *S, which lets us create
recursive data structures like linked lists and trees. This is illustrated in the code below, which uses a binary
tree to implement an insertion sort:

gopl.io/ch4/treesort
================================================================================================================================
The struct type with no fields is called the empty struct, written struct{}. It has size zero and
carries no information but may be useful nonetheless. Some Go programmers use it instead
of bool as the value type of a map that represents a set, to emphasize that only the keys are significant,
but the space saving is marginal(微小的，少量的) and the syntax more cumbersome, so we generally avoid it.

seen := make(map[string]struct{}) // set of strings
// ...
if _, ok := seen[s]; !ok {
  seen[s] = struct{}{}
  // ...first time seeing s...
}
================================================================================================================================
package p
type T struct{ a, b int } // a and b are not exported

package q
import "p"
var _ = p.T{a: 1, b: 2} // compile error: can't reference a, b
var _ = p.T{1, 2} // compile error: can't reference a, b

Although the last line above doesn't mention the unexported field identifiers, it's
really using them implicitly, so it's not allowed.
================================================================================================================================
If all the fields of a struct are comparable, the struct itself is comparable, so two expressions of that
type may be compared using == or !=. The == operation compares the corresponding fields of the two structs
in order, so the two printed expressions below are equivalent:

type Point struct{ X, Y int }

p := Point{1, 2}
q := Point{2, 1}
fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
fmt.Println(p == q)                   // "false"

Comparable struct types, like other comparable types, may be used as the key type of a map.

type address struct {
    hostname string
    port     int
}

hits := make(map[address]int)
hits[address{"golang.org", 443}]++
================================================================================================================================
p104
4.4.3. Struct Embedding and Anonymous Fields
================================================================================================================================
You may occasionally encounter a function declaration without a body, indicating that the
function is implemented in a language other than Go. Such a declaration defines the function signature.

package math
func Sin(x float64) float64 // 由汇编做的函数实现
================================================================================================================================
The golang.org/x/... repositories hold packages designed and maintained by the Go team for applications such as
networking, internationalized text processing, mobile platforms, image manipulation, cryptography, and developer
tools. These packages are not in the standard library because they're still under development or because
they're rarely needed by the majority of Go programmers.
================================================================================================================================
代码: gopl.io/ch5/outline

Note one subtlety: although outline "pushes" an element on stack, there is no corresponding
pop. When outline calls itself recursively, the callee(被调用者) receives a copy of stack. Although the
callee may append elements to this slice, modifying its underlying array and perhaps even
allocating a new array, it doesn't modify the initial elements that are visible to the caller, so
when the function returns, the caller's stack is as it was before the call.

有一点值得注意：outline有入栈操作，但没有相对应的出栈操作。
当outline调用自身时，被调用者接收的是stack的拷贝。被调用者的入栈操作，修改的是stack的拷贝，而不是调
用者的stack,因对当函数返回时,调用者的stack并未被修改。

我来写段测试代码验证这个问题
package main

import (
	"fmt"
)

func main() {
	x := []string{"a", "b", "c"}
	fmt.Println("x1: ", x)
	a(x)
	fmt.Println("x2: ", x)

}

func a(m []string) {
	m = append(m, "y")
	fmt.Println("y", m)
}

//output:
/**
x1:  [a b c]
y [a b c y]
x2:  [a b c]
*/
================================================================================================================================
We must ensure that resp.Body is closed so that network resources are properly released even
in case of error. Go's garbage collector recycles unused memory, but do not assume it will
release unused operating system resources like open files and network connections. They should be closed explicitly.
比如 resp.Body.Close()
================================================================================================================================
The result of a multi-valued call may itself be returned from a (multi-valued) calling function,
as in this function that behaves like findLinks but logs its argument:

func findLinksLog(url string) ([]string, error) {
  log.Printf("findLinks %s", url)
  return findLinks(url)
}

A multi-valued call may appear as the sole argument when calling a function of multiple parameters. Although rarely used
in production code, this feature is sometimes convenient during debugging since it lets us print all the results of a call
using a single statement. The two print statements below have the same effect.

log.Println(findLinks(url))

links, err := findLinks(url)
log.Println(links, err)
================================================================================================================================
Usually when a function returns a non-nil error, its other results are undefined and should be
ignored. However, a few functions may return partial results in error cases. For example, if an
error occurs while reading from a file, a call to Read returns the number of bytes it was able to
read and an error value describing the problem. For correct behavior, some callers may need
to process the incomplete data before handling the error, so it is important that such functions
clearly document their results.

**
以下是文档中的描述
$ go doc os.File.Read
func (f *File) Read(b []byte) (n int, err error)

    Read reads up to len(b) bytes from the File. It returns the number of bytes
    read and an error, if any. EOF is signaled by a zero count with err set to
    io.EOF.
**
================================================================================================================================
doc, err := html.Parse(resp.Body)
resp.Body.Close()
  if err != nil {
  return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
}

The fmt.Errorf function formats an error message using fmt.Sprintf and returns a new
error value. We use it to build descriptive errors by successively prefixing additional context
information to the original error message . When the error is ultimately handled by the
program's main function, it should provide a clear causal chain from the root problem to the
overall failure, reminiscent of a NASA accident investigation:

genesis: crashed: no parachute: G-switch failed: bad relay orientation

Because error messages are frequently chained together, message strings should not be capitalized and newlines
should be avoided. The resulting errors may be long, but they will be selfcontained when found by tools like grep.
================================================================================================================================
// (In function main.)
if err := WaitForServer(url); err != nil {
  fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
  os.Exit(1)
}

A more convenient way to achieve the same effect is to call log.Fatalf. As with all the log
functions, by default it prefixes the time and date to the error message.

if err := WaitForServer(url); err != nil {
  log.Fatalf("Site is down: %v\n", err)
}

The default format is helpful in a long-running server, but less so for an interactive tool:

2006/01/02 15:04:05 Site is down: no such domain: bad.gopl.io

For a more attractive output, we can set the prefix used by the log package to the name of the
command, and suppress the display of the date and time:

log.SetPrefix("wait: ")
log.SetFlags(0)
================================================================================================================================
in rare cases we can safely ignore an error entirely:

dir, err := ioutil.TempDir("", "scratch") // $ go doc ioutil.TempDir 查看定义
if err != nil {
  return fmt.Errorf("failed to create temp dir: %v", err)
}
// ...use temp dir...
os.RemoveAll(dir) // ignore errors; $TMPDIR is cleaned periodically

The call to os.RemoveAll may fail, but the program ignores it because the operating system
periodically cleans out the temporary directory. In this case, discarding the error was intentional,
but the program logic would be the same had we forgotten to deal with it. Get into the
habit of considering errors after every function call, and when you deliberately ignore one,
document your intention clearly.
================================================================================================================================
The zero value of a function type is nil. Calling a nil function value causes a panic
================================================================================================================================
Function values may be compared with nil:

var f func(int) int

if f != nil {
  f(3)
}

but they are not comparable, so they may not be compared against each other or used as keys in a map.
================================================================================================================================
Function values let us parameterize our functions over not just data, but behavior too. The standard libraries
contain many examples. For instance, strings.Map applies a function to each character of a string, joining the
results to make another string.

func add1(r rune) rune { return r + 1 }
fmt.Println(strings.Map(add1, "HAL-9000")) // "IBM.:111"
fmt.Println(strings.Map(add1, "VMS")) // "WNT"
fmt.Println(strings.Map(add1, "Admix")) // "Benjy"

通过 $ go doc strings.Map 查看函数定义
================================================================================================================================
The functions also indent the output using another fmt.Printf trick. The * adverb in %*s
prints a string padded with a variable number of spaces. The width and the string are
provided by the arguments depth*2 and "".

gopl.io/ch5/outline2
================================================================================================================================
/gopl.io/ch5/toposort

When an anonymous function requires recursion, as in this example, we must first declare a
variable, and then assign the anonymous function to that variable. Had these two steps been
combined in the declaration, the function literal would not be within the scope of the variable
visitAll so it would have no way to call itself recursively:

visitAll := func(items []string) {
  // ...
  visitAll(m[item]) // compile error: undefined: visitAll
  // ...
}
================================================================================================================================
到此
Instead of appending the raw href attribute value to the links slice, this version parses it as a
URL relative to the base URL of the document, resp.Request.URL. The resulting link is in
absolute form, suitable for use in a call to http.Get.

gopl.io/ch5/links
================================================================================================================================
p140 : 5.6.1. Caveat: Capturing Iteration Variables
================================================================================================================================
Although the ...int parameter behaves like a slice within the function body, the type of a
variadic function is distinct from the type of a function with an ordinary slice parameter.

func f(...int) {}
func g([]int) {}

fmt.Printf("%T\n", f) // "func(...int)"
fmt.Printf("%T\n", g) // "func([]int)"

...int 只是行为上像 slice
================================================================================================================================
Because deferred functions aren't executed until the very end of a function's execution, a
defer statement in a loop deserves extra scrutiny(scrutiny:详细查看,监视). The code below could run out of file
descriptors since no file will be closed until all files have been processed:

for _, filename := range filenames {
  f, err := os.Open(filename)
  if err != nil {
    return err
  }
  defer f.Close() // NOTE: risky; could run out of file descriptors
  // ...process f...
}

One solution is to move the loop body, including the defer statement, into another function
that is called on each iteration.

for _, filename := range filenames {
  if err := doFile(filename); err != nil {
    return err
  }
}

func doFile(filename string) error {
  f, err := os.Open(filename)
  if err != nil {
    return err
  }
  defer f.Close()
  // ...process f...
}
================================================================================================================================
The deferred call to resp.Body.Close should be familiar by now. It's tempting to use a
second deferred call, to f.Close, to close the local file, but this would be subtly wrong because
os.Create opens a file for writing, creating it as needed. On many file systems, notably NFS,
write errors are not reported immediately but may be postponed until the file is closed. Failure
to check the result of the close operation could cause serious data loss to go unnoticed(go unnoticed:不被差觉的).
However, if both io.Copy and f.Close fail, we should prefer to report the error from
io.Copy since it occurred first and is more likely to tell us the root cause.

gopl.io/ch5/fetch
================================================================================================================================
It's good practice to assert that the preconditions of a function hold, but this can easily be done
to excess(to excess: 过多,过度). Unless you can provide a more informative error message or detect an error sooner,
there is no point(there is no point doing做某事没有意义) asserting a condition that the runtime will check for you.

func Reset(x *Buffer) {
  if x == nil {
    panic("x is nil") // unnecessary!
  }
  x.elements = nil
}
================================================================================================================================
Although Go's panic mechanism resembles exceptions in other languages, the situations in
which panic is used are quite different. Since a panic causes the program to crash, it is generally
used for grave(重大的,严重的) errors, such as a logical inconsistency in the
program; diligent(diligent adj. 勤勉的；用功的，费尽心血的) programmers
consider any crash to be proof of a bug in their code. In a robust program, "expected(可预期的)"
errors, the kind that arise from incorrect input, misconfiguration, or failing I/O, should be
handled gracefully; they are best dealt with using error values.
================================================================================================================================
var httpSchemeRE = regexp.MustCompile(`^https?:`) // http: or https:
================================================================================================================================
gopl.io/ch5/defer1
为什么没有打印 'defer 0' ??????
================================================================================================================================
Readers familiar with exceptions in other languages may be surprised that runtime.Stack
can print information about functions that seem to have already been "unwound". Go's panic
mechanism runs the deferred functions before it unwinds the stack.
gopl.io/ch5/defer2
================================================================================================================================
5.10. Recover
================================================================================================================================
6.2. Methods with a Pointer Receiver
================================================================================================================================
6.2.1. Nil Is a Valid Receiver Value
================================================================================================================================
6.3. Composing Types by Struct Embedding
================================================================================================================================
6.4. Method Values and Expressions
================================================================================================================================
6.5. Example: Bit Vector Type
================================================================================================================================
gopl.io/ch7/bytecounter
================================================================================================================================
A type satisfies an interface if it possesses all the methods the interface requires. For example,
an *os.File satisfies io.Reader, Writer, Closer, and ReadWriter. A *bytes.Buffer satisfies
Reader, Writer, and ReadWriter, but does not satisfy Closer because it does not have a
Close method. As a shorthand, Go programmers often say that a concrete type "is a" particular
interface type, meaning that it satisfies the interface. For example, a *bytes.Buffer is an
io.Writer ; an *os.File is an io.ReadWriter .
================================================================================================================================
The assignability rule (§2.4.2) for interfaces is very simple: an expression may be assigned to
an interface only if its type satisfies the interface. So:

var w io.Writer
w = os.Stdout  // OK: *os.File has Write method
w = new(bytes.Buffer)  // OK: *bytes.Buffer has Write method
w = time.Second  // compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc = os.Stdout // OK: *os.File has Read, Write, Close methods
rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method

This rule applies even when the right-hand side is itself an interface:
w = rwc // OK: io.ReadWriteCloser has Write method
rwc = w // compile error: io.Writer lacks Close method

Because ReadWriter and ReadWriteCloser include all the methods of Writer, any type that
satisfies ReadWriter or ReadWriteCloser necessarily satisfies Writer.
================================================================================================================================
p176
Before we go further, we should explain one subtlety in what it means for a type to have a
method. Recall from Section 6.2 that for each named concrete type T, some of its methods
have a receiver of type T itself whereas others require a *T pointer. Recall also that it is legal to
call a *T method on an argument of type T so long as the argument is a variable; the compiler
implicitly takes its address. But this is mere syntactic sugar: a value of type T does not possess
all the methods that a *T pointer does, and as a result it might satisfy fewer interfaces.

An example will make this clear. The String method of the IntSet type from Section 6.5
requires a pointer receiver, so we cannot call that method on a non-addressable IntSet value:

type IntSet struct { /* ... */ }
func (*IntSet) String() string
var _ = IntSet{}.String() // compile error: String requires *IntSet receiver

but we can call it on an IntSet variable:

var s IntSet
var _ = s.String() // OK: s is a variable and &s has a String method

However, since only *IntSet has a String method, only *IntSet satisfies the fmt.Stringer interface:
var _ fmt.Stringer = &s // OK
var _ fmt.Stringer = s // compile error: IntSet lacks String method

Section 12.8 includes a program that prints the methods of an arbitrary value, and the
godoc -analysis=type to ol (§10.7.4) displays the methods of each type and the relationship
between interfaces and concrete types.

Like an envelope that wraps and conceals the letter it holds, an interface wraps and conceals
the concrete type and value that it holds. Only the methods revealed by the interface type may
be called, even if the concrete type has others:

os.Stdout.Write([]byte("hello")) // OK: *os.File has Write method
os.Stdout.Close() // OK: *os.File has Close method
var w io.Writer
w = os.Stdout
w.Write([]byte("hello")) // OK: io.Writer has Write method
w.Close() // compile error: io.Writer lacks Close method
================================================================================================================================
p177
Since interface satisfaction depends only on the methods of the two types involved, there is no
need to declare the relationship between a concrete type and the interfaces it satisfies. That
said, it is occasionally useful to document and assert the relationship when it is intended but
not other wise enforced by the program. The declaration below asserts at compile time that a
value of type *bytes.Buffer satisfies io.Writer:

// *bytes.Buffer must satisfy io.Writer
var w io.Writer = new(bytes.Buffer)

We needn't allocate a new variable since any value of type *bytes.Buffer will do, even nil,
which we write as (*bytes.Buffer)(nil) using an explicit conversion. And since we never
intend to refer to w, we can replace it with the blank identifier. Together, these changes give us
this more frugal(节俭的；朴素的) variant:
// *bytes.Buffer must satisfy io.Writer
var _ io.Writer = (*bytes.Buffer)(nil)
================================================================================================================================
7.4. Parsing Flags with flag.Value
7.5. Interface Values
7.5.1. Caveat: An Interface Containing a Nil Pointer Is Non-Nil
7.6. Sorting with sort.Interface
================================================================================================================================
gopl.io/ch7/sorting


type Track struct {
	Title  string
	Artist string
	Album  string
	Year   int
	Length time.Duration
}

var tracks = []*Track{
	{"Go", "Delilah", "From the Roots Up", 2012, length("3m38s")},
	{"Go", "Moby", "Moby", 1992, length("3m37s")},
	{"Go Ahead", "Alicia Keys", "As I Am", 2007, length("4m36s")},
	{"Ready 2 Go", "Martin Solveig", "Smash", 2011, length("4m24s")},
}

func length(s string) time.Duration {
	d, err := time.ParseDuration(s)
	if err != nil {
		panic(s)
	}
	return d
}

这种声明与初始化的方式, 首先,在 {"Go", "Delilah", "From the Roots Up", 2012, length("3m38s")}, 省略了 Track 的类型,
其次,[]*Track 每个slice元素应该是一个指针,这里也没有用取地址
最后,初始化的时候,调用了 length 函数
================================================================================================================================
7.10. Type Assertions
7.11. Discriminating Errors with Type Assertions
7.12. Querying Behaviors with Interface Type Assertions
7.13. Type Switches
================================================================================================================================
As with other reference types, the zero value of a channel is nil.
Two channels of the same type may be compared using ==. The comparison is true if both are
references to the same channel data structure. A channel may also be compared to nil.
================================================================================================================================
In a send statement, the <- separates the channel and value operands. In a receive expression, <- precedes
the channel operand. A receive expression whose result is not used is a valid statement.

ch <- x  // a send statement
x = <-ch // a receive expression in an assignment statement
<-ch // a receive statement; result is discarded
================================================================================================================================
Channels support a third operation, close, which sets a flag indicating that no more values will
ever be sent on this channel; subsequent attempts to send will panic. Receive operations on a
closed channel yield the values that have been sent until no more values are left; any receive
operations thereafter complete immediately and yield the zero value of the channel's element type.
================================================================================================================================
第八章,从 8.4.1. Unbuffered Channels 到结束,都可以多看看
================================================================================================================================
gopl.io/ch8/countdown3

The time.Tick function behaves as if it creates a goroutine that calls time.Sleep in a loop,
sending an event each time it wakes up. When the countdown function above returns, it stops
receiving events from tick, but the ticker goroutine is still there, trying in vain to send on a
channel from which no goroutine is receiving—a goroutine leak (§8.4.4).

The Tick function is convenient, but it's appropriate only when the ticks will be needed
throughout the lifetime of the application. Otherwise, we should use this pattern:

ticker := time.NewTicker(1 * time.Second)
<-ticker.C // receive from the ticker's channel
ticker.Stop() // cause the ticker's goroutine to terminate
================================================================================================================================
Sometimes we want to try to send or receive on a channel but avoid blocking if the channel is
not ready—a non-blocking communication. A select statement can do that too. A select
may have a default, which specifies what to do when none of the other communications can
proceed immediately.

The select statement below receives a value from the abort channel if there is one to receive;
otherwise it does nothing. This is a non-blocking receive operation; doing it repeatedly is
called polling a channel.

select {
case <-abort:
  fmt.Printf("Launch aborted!\n")
  return
default:
  // do nothing
}

The zero value for a channel is nil. Perhaps surprisingly, nil channels are sometimes useful.
Because send and receive operations on a nil channel block forever, a case in a select statement
whose channel is nil is never selected. This lets us use nil to enable or disable cases that correspond
to features like handling timeouts or cancellation, responding to other input events, or emitting output. 
================================================================================================================================
it is so important: A data race occurs whenever two goroutines access the same variable
concurrently and at least one of the accesses is a write.
================================================================================================================================
gopl.io/ch9/bank3
By convention, the variables guarded by a mutex are declared immediately after the declaration of the
mutex itself. If you deviate from this, be sure to document it.
================================================================================================================================
The region of code between Lock and Unlock in which a goroutine is free to read and modify
the shared variables is called a critical section.
================================================================================================================================
gopl.io/ch9/memo1
gopl.io/ch9/memo2
gopl.io/ch9/memo3
gopl.io/ch9/memo4
gopl.io/ch9/memo5
================================================================================================================================
If we need to import two packages whose names are the same, like math/rand and
crypto/rand, into a third package, the import declaration must specify an alternative name
for at least one of them to avoid a conflict. This is called a renaming import.

import (
  "crypto/rand"
  mrand "math/rand" // alternative name mrand avoids conflict
)

The alternative name affects only the importing file. Other files, even ones in the same
package, may import the package using its default name, or a different name.

A renaming import may be useful even when there is no conflict. If the name of the imported
package is unwieldy, as is sometimes the case for automatically generated code, an abbreviated
name may be more convenient. The same short name should be used consistently to avoid
confusion. Choosing an alternative name can help avoid conflicts with common local variable
names. For example, in a file with many local variables named path, we might import the
standard "path" package as pathpkg.
================================================================================================================================
The go get command has support for popular code-hosting sites like GitHub, Bitbucket, and
Launchpad and can make the appropriate requests to their version-control systems. For less
well-known sites, you may have to indicate which version-control protocol to use in the
import path, such as Git or Mercurial. Run go help importpath for the details.
================================================================================================================================
If you specify the -u flag, go get will ensure that all packages it visits, including dependencies,
are updated to their latest version before being built and installed. Without that flag, packages
that already exist locally will not be updated.
The go get -u command generally retrieves the latest version of each package, which is con-
venient when you're getting started but may be inappropriate for deployed projects, where
precise control of dependencies is critical for release hygiene. The usual solution to this
problem is to vendor the code, that is, to make a persistent local copy of all the necessary
dependencies, and to update this copy carefully and deliberately. Prior to Go 1.5, this required
changing those packages's import paths, so our copy of golang.org/x/net/html would
become gopl.io/vendor/golang.org/x/net/html. More recent versions of the go tool
support vendoring directly, though we don't have space to show the details here. See Vendor
Directories in the output of the go help gopath command.
================================================================================================================================
For convenience, go build -i installs the packages that are dependencies of the build target.
================================================================================================================================
$ go doc time
$ go doc time.Since
$ go doc time.Duration.Seconds

The tool does not need complete import paths or correct identifier case. This command prints
the documentation of (*json.Decoder).Decode from the encoding/json package:

$ go doc json.decode
func (dec *Decoder) Decode(v interface{}) error
Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.

$ godoc -analysis=type,pointer -http :8000

================================================================================================================================
10.7.5. Internal Packages
10.7.6. Querying Packages
================================================================================================================================
11.2.4. External Test Packages
================================================================================================================================
p329   12章 反射
================================================================================================================================
fmt.Println(os.Args[1:]) // Println 可用于调试 slice
================================================================================================================================
printf 的常用 verb
%d decimal integer
%x, %o, %b integer in hexade cimal, octal, binary
%f, %g, %e floating-p oint number: 3.141593 3.141592653589793 3.141593e+00
%t boolean: true or false
%c rune (Unicode code point)
%s string
%q quoted string "abc" or rune 'c'
%v any value in a natural format
%T type of any value
%% literal percent sign (no operand)
================================================================================================================================
By convention, formatting functions whose names end in f, such as
log.Printf and fmt.Errorf, use the formatting rules of fmt.Printf, whereas those whose
names end in ln follow Println, formatting their arguments as if by %v, follow ed by a newline.
================================================================================================================================
When a map is passed to a function, the function receives a copy of the reference, so any changes the called function makes to
the underlying datastructure will be visible through the caller’s map reference too.
================================================================================================================================
One subtle but important point: a short variable declaration does not necessarily declare all the
variables on its left-hand side. If some of them were already declared in the same lexical block
(§2.7), then the short variable declaration acts like an assignment to those variables.

In the code below, the first statement declares both in and err. The second declares out but only assigns a value to the existing err variable.
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)

A short variable declaration must declare at least one new variable, however, so this code will not compile:
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables

The fix is to use an ordinary assignment for the second statement.

A short variable declaration acts like an assignment only to variables that were already
declared in the same lexical block; declarations in an outer block are ignored. 
================================================================================================================================
The behavior of % for negative numbers varies across programming languages. In Go, the sign of the remainder is
always the same as the sign of the dividend(被除数), so -5%3 and -5%-3 are both -2. The behavior of /
depends on whether its operands are integers, so 5.0/4.0 is 1.25, but 5/4 is 1 because integer
division truncates the result toward zero.
================================================================================================================================
If the result of an arithmetic operation, whether signed or unsigned, has more bits than can be represented in the
result type, it is said to overflow. The high-order bits that do not fit are silently discarded. If the original
number is a signed type, the result could be negative if the leftmost bit is a 1, as in the int8 example here:

var u uint8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"

var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 -128 1"
================================================================================================================================
^ 	bitwise XOR
&^ 	bit clear (AND NOT)

The operator ^ is bitwise exclusive OR (XOR) when used as a binary operator, but when used as a unary prefix
operator it is bitwise negation or complement; that is, it returns a value with each bit in its operand inverted.
The &^ operator is bit clear (AND NOT): in the expression z = x &^ y, each bit of z is 0 if the corresponding
bit of y is 1; otherwise it equals the corresponding bit of x.
 
The code below shows how bitwise operations can be used to interpret a uint8 value as a compact and efficient
set of 8 independent bits. It uses Printf’s %b verb to print a number’s binary digits; 08 modifies %b (an adverb!) to
pad the result with zeros to exactly 8 digits.


var x uint8 = 1<<1 | 1<<5
var y uint8 = 1<<1 | 1<<2

fmt.Printf("%08b\n", x)    // "00100010", the set {1, 5}
fmt.Printf("%08b\n", y)    // "00000110", the set {1, 2}

fmt.Printf("%08b\n", x&y)  // "00000010", the intersection {1}
fmt.Printf("%08b\n", x|y)  // "00100110", the union {1, 2, 5}
fmt.Printf("%08b\n", x^y)  // "00100100", the symmetric difference {2, 5}
fmt.Printf("%08b\n", x&^y) // "00100000", the difference {5}

for i := uint(0); i < 8; i++ {
    if x&(1<<i) != 0 { // membership test
        fmt.Println(i) // "1", "5"
    }
}

fmt.Printf("%08b\n", x<<1) // "01000100", the set {2, 6}
fmt.Printf("%08b\n", x>>1) // "00010001", the set {0, 4}
================================================================================================================================
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF

Note the use of two fmt tricks. Usually a Printf format string containing multiple % verbs would require the same
number of extra operands, but the [1] “adverbs” after % tell Printf to use the first operand over and over again.
Second, the # adverb for %o or %x or %X tells Printf to emit a 0 or 0x or 0X prefix respectively. 
================================================================================================================================
 Rune literals are written as a character within single quotes. The simplest example is an ASCII character like 'a', but it’s possible to write any Unicode code point either directly or with numeric escapes, as we will see shortly.

Runes are printed with %c, or with %q if quoting is desired:

ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
================================================================================================================================
A float32 provides approximately six decimal digits of precision, whereas a float64 provides about 15 digits; float64
should be preferred for most purposes because float32 computations accumulate error rapidly unless one is quite
careful, and the smallest positive integer that cannot be exactly represented as a float32 is not large:

var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
================================================================================================================================
p57
Floating-point values are conveniently printed with Printf’s %g verb, which chooses the most compact representation that has adequate precision, but for tables of data, the %e (exponent) or %f (no exponent) forms may be more appropriate. All three verbs allow field width and numeric precision to be controlled.

for x := 0; x < 8; x++ {
    fmt.Printf("x = %d ex = %8.3f\n", x, math.Exp(float64(x)))
}

The code above prints the powers of e with three decimal digits of precision, aligned in an eight-character field:

x = 0   ex =    1.000
x = 1   ex =    2.718
x = 2   ex =    7.389
x = 3   ex =   20.086
x = 4   ex =   54.598
x = 5   ex =  148.413
x = 6   ex =  403.429
x = 7   ex = 1096.633
================================================================================================================================
Map elements are accessed through the usual subscript notation:
  ages["alice"] = 32
  fmt.Println(ages["alice"]) // "32"
and removed with the built-in function delete:
  delete(ages, "alice") // remove element ages["alice"]
All of these operations are safe even if the element isn’t in the map; a map lookup using a key
that isn’t present returns the zero value for its type, so, for instance, the following works even
when "bob" is not yet a key in the map because the value of ages["bob"] will be 0.
  ages["bob"] = ages["bob"] + 1 // happy birthday!
The shorthand assignment forms x += y and x++ also work for map elements, so we can rewrite the statement above as
  ages["bob"] += 1
or evenmore concisely as
  ages["bob"]++
But a map element is not a variable, and we cannot take its address:
  _ = &ages["bob"] // compile error: cannot take address of map element
One reason that we can’t take the address of a map element is that growing a map might cause
rehashing of existing elements into new storage locations, thus potentially invalidating the address.
================================================================================================================================
In a realistic program, convention dictates that if any method of Point has a pointer receiver,
then all methods of Point should have a pointer receiver, even ones that don’t strictly need it.
================================================================================================================================
Named types (Point) and pointers to them (*Point) are the only types that may appear in a
receiver declaration. Furthermore, to avoid ambiguities, method declarations are not permitted
on named types that are themselves pointer types:
type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
================================================================================================================================
Usually we select and call a method in the same expression, as in p.Distance(), but it’s possible to separate these two operations. The selector p.Distance yields a method value, a function that binds a method (Point.Distance) to a specific receiver value p. This function can then be invoked without a receiver value; it needs only the non-receiver arguments.


p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance        // method value
fmt.Println(distanceFromP(q))      // "5"
var origin Point                   // {0, 0}
fmt.Println(distanceFromP(origin)) // "2.23606797749979", √5

scaleP := p.ScaleBy // method value
scaleP(2)           // p becomes (2, 4)
scaleP(3)           //      then (6, 12)
scaleP(10)          //      then (60, 120)

Method values are useful when a package’s API calls for a function value, and the client’s desired behavior for that function is to call a method on a specific receiver. For example, the function time.AfterFunc calls a function value after a specified delay. This program uses it to launch the rocket r after 10 seconds:

type Rocket struct { /* ... */ }
func (r *Rocket) Launch() { /* ... */ }

r := new(Rocket)
time.AfterFunc(10 * time.Second, func() { r.Launch() })

The method value syntax is shorter:

Click here to view code image

time.AfterFunc(10 * time.Second, r.Launch)
================================================================================================================================
Related to the method value is the method expression. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written T.f or (*T).f where T is a type, yields a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way.

p := Point{1, 2}
q := Point{4, 6}

distance := Point.Distance   // method expression
fmt.Println(distance(p, q))  // "5"
fmt.Printf("%T\n", distance) // "func(Point, Point) float64"

scale := (*Point).ScaleBy
scale(&p, 2)
fmt.Println(p)            // "{2 4}"
fmt.Printf("%T\n", scale) // "func(*Point, float64)"

Method expressions can be helpful when you need a value to represent a choice among several methods belonging to the same type so that you can call the chosen method with many different receivers. In the following example, the variable op represents either the addition or the subtraction method of type Point, and Path.TranslateBy calls it for each point in the Path:

type Point struct{ X, Y float64 }

func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) {
    var op func(p, q Point) Point
    if add {
        op = Point.Add
    } else {
        op = Point.Sub
    }
    for i := range path {
        // Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] = op(path[i], offset)
    }
}
================================================================================================================================
6.5. Example: Bit Vector Type
================================================================================================================================
The assignability rule for interfaces is very simple: an expression may be assigned to
an interface only if its type satisfies the interface. So:

var w io.Writer
w = os.Stdout // OK: *os.File has Write method
w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method
w = time.Second // compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc = os.Stdout // OK: *os.File has Read, Write, Close methods
rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method

This rule applies even when the right-hand side is itself an interface:

w = rwc // OK: io.ReadWriteCloser has Write method
rwc = w // compile error: io.Writer lacks Close method
================================================================================================================================
Like an envelope that wraps and conceals the letter it holds, an interface wraps and conceals
the concrete type and value that it holds. Only the methods revealed by the interface type may
be called, even if the concrete type has others:

os.Stdout.Write([]byte("hello")) // OK: *os.File has Write method
os.Stdout.Close() // OK: *os.File has Close method

var w io.Writer
w = os.Stdout

w.Write([]byte("hello")) // OK: io.Writer has Write method
w.Close() // compile error: io.Writer lacks Close method
================================================================================================================================
Since interface satisfaction depends only on the methods of the two types involved, there is no need to declare the relationship between a concrete type and the interfaces it satisfies. That said, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below asserts at compile time that a value of type *bytes.Buffer satisfies io.Writer:

// *bytes.Buffer must satisfy io.Writer
var w io.Writer = new(bytes.Buffer)

frugal   ['fru:ɡəl] adj.
1.节俭的，节约的，俭朴的
2.不昂贵的，廉价的；不豪华的；不充足的

We needn’t allocate a new variable since any value of type *bytes.Buffer will do, even nil, which we write as (*bytes.Buffer)(nil) using an explicit conversion. And since we never intend to refer to w, we can replace it with the blank identifier. Together, these changes give us this more frugal variant:

// *bytes.Buffer must satisfy io.Writer
var _ io.Writer = (*bytes.Buffer)(nil)
================================================================================================================================
Interface values may be compared using == and !=. Two interface values are equal if both are nil, or if their dynamic types are identical and their dynamic values are equal according to the usual behavior of == for that type. Because interface values are comparable, they may be used as the keys of a map or as the operand of a switch statement.

However, if two interface values are compared and have the same dynamic type, but that type is not comparable (a slice, for instance), then the comparison fails with a panic:

var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int

In this respect, interface types are unusual. Other types are either safely comparable (like basic types and pointers) or not comparable at all (like slices, maps, and functions), but when comparing interface values or aggregate types that contain interface values, we must be aware of the potential for a panic. A similar risk exists when using interfaces as map keys or switch operands. Only compare interface values if you are certain that they contain dynamic values of comparable types.

When handling errors, or during debugging, it is often helpful to report the dynamic type of an interface value. For that, we use the fmt package’s %T verb:

var w io.Writer
fmt.Printf("%T\n", w) // "<nil>"

w = os.Stdout
fmt.Printf("%T\n", w) // "*os.File"

w = new(bytes.Buffer)
fmt.Printf("%T\n", w) // "*bytes.Buffer"

Internally, fmt uses reflection to obtain the name of the interface’s dynamic type.
================================================================================================================================
7.5.1. Caveat: An Interface Containing a Nil Pointer IsNon-Nil
p341 12.5 Setting Variables with reflect.Value
p344 12.6. Example: Decoding S-Expressions
p348 12.7. Accessing Struct Field Tags
12.8. Displaying the Methods of a Type
================================================================================================================================
ch12/sexpr
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================
